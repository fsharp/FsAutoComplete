<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFrameworks>net6.0;net7.0;net8.0</TargetFrameworks>
    <TargetFrameworks Condition="'$(BuildNet7)' == 'true'">net6.0;net7.0</TargetFrameworks>
    <TargetFrameworks Condition="'$(BuildNet8)' == 'true'">net6.0;net7.0;net8.0</TargetFrameworks>
    <RuntimeIdentifiers>
      win-x64;linux-x64;linux-arm64;osx-x64;osx-arm64;linux-musl-x64;linux-musl-arm64</RuntimeIdentifiers>
    <AssemblyName>fsautocomplete</AssemblyName>
    <ServerGarbageCollection>true</ServerGarbageCollection>
    <ConcurrentGarbageCollection>true</ConcurrentGarbageCollection>
    <PackageReadmeFile>README.md</PackageReadmeFile>
    <Description>A community-developed Language Server Protocol implementation for F#</Description>
    <PackageLicenseExpression>Apache-2.0</PackageLicenseExpression>
    <PackageIcon>logo.png</PackageIcon>
    <PackageProjectUrl>$(RepositoryUrl)</PackageProjectUrl>
    <Authors>FsAutoComplete contributors</Authors>
    <SatelliteResourceLanguages>en</SatelliteResourceLanguages>
    <IsPackable>true</IsPackable>
    <PackAsTool>true</PackAsTool>
    <PublishSingleFile>true</PublishSingleFile>
    <PublishSelfContained>true</PublishSelfContained>
    <DebugType>embedded</DebugType>
    <IncludeNativeLibrariesForSelfExtract>true</IncludeNativeLibrariesForSelfExtract>
  </PropertyGroup>
  <ItemGroup>
    <None
        Include="../../README.md"
        Pack="true"
        PackagePath="\" />
    <None
        Include="logo.png"
        Pack="true"
        PackagePath="\" />
    <Compile Include="CommandResponse.fsi" />
    <Compile Include="CommandResponse.fs" />
    <Compile Include="JsonSerializer.fs" />
    <Compile Include="LspHelpers.fsi" />
    <Compile Include="LspHelpers.fs" />
    <Compile Include="CodeFixes.fsi" />
    <Compile Include="CodeFixes.fs" />
    <Compile Include="CodeFixes/*.fsi" />
    <Compile Include="CodeFixes/*.fs" />
    <Compile Include="LspServers/IFSharpLspServer.fs" />
    <Compile Include="LspServers/FSharpLspClient.fsi" />
    <Compile Include="LspServers/FSharpLspClient.fs" />
    <Compile Include="LspServers/Common.fs" />
    <Compile Include="LspServers/AdaptiveServerState.fsi" />
    <Compile Include="LspServers/AdaptiveServerState.fs" />
    <Compile Include="LspServers/AdaptiveFSharpLspServer.fsi" />
    <Compile Include="LspServers/AdaptiveFSharpLspServer.fs" />
    <Compile Include="Parser.fsi" />
    <Compile Include="Parser.fs" />
    <Compile Include="Program.fs" />
    <None Include="FsAutoComplete.fsproj.paket.references" />
    <Content Include="default.win32manifest">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </Content>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\FsAutoComplete.Core\FsAutoComplete.Core.fsproj" />
  </ItemGroup>
  <PropertyGroup Condition=" '$(PackAsTool)' == 'true' ">
    <AssemblyName>fsautocomplete</AssemblyName>
    <PackageId>fsautocomplete</PackageId>
    <ToolCommandName>fsautocomplete</ToolCommandName>
    <PackageType>DotnetTool</PackageType>
    <!-- This rollforward enables us to actually run on the .net 6 runtime without
         retargeting the whole app, minimizing packaged binary size. -->
    <RollForward>LatestMajor</RollForward>
    <!-- workaround for not being able to have p2p dependencies in tool output dir
    https://github.com/nuget/home/issues/3891#issuecomment-377319939 -->
    <TargetsForTfmSpecificBuildOutput>
      $(TargetsForTfmSpecificBuildOutput);CopyProjectReferencesToPackage</TargetsForTfmSpecificBuildOutput>
  </PropertyGroup>

  <ItemGroup Label="Trimming Settings">
    <TrimmerRootAssembly Include="Serilog" />
    <TrimmerRootAssembly Include="Ionide.ProjInfo.ProjectSystem" />
  </ItemGroup>

  <!-- workaround for not being able to have p2p dependencies in tool output dir
  https://github.com/nuget/home/issues/3891#issuecomment-377319939 -->
  <Target
      Name="CopyProjectReferencesToPackage"
      DependsOnTargets="ResolveReferences">
    <ItemGroup>
      <BuildOutputInPackage Include="@(ReferenceCopyLocalPaths -> WithMetadataValue('ReferenceSourceTarget', 'ProjectReference'))" />
    </ItemGroup>
  </Target>

  <Target Name="BuildAllStandloneApplications">
    <ItemGroup>
      <!-- Make MSBuild Items out of the RIDs so we can batch across them -->
      <_RIDS Include="$(RuntimeIdentifiers)" />
      <!-- Make MSBuild Items out of the TFMs so we can batch across them. Create NUM_RIDS items
      per-TFM because we want to build each TFM for all supported platforms. -->
      <_TFMS
          Include="$(TargetFrameworks)"
          RID="%(_RIDS.Identity)" />
      <!-- Turn the _TFMS items into requests to build this project (fsautocomplete.fsproj) with
      different parameters. This pattern is often used to to parallel builds of the same project in
      MSBuild logic. -->
      <_RIDSpecificFSACBuild
          Include="$(MSBuildThisFile)"
          AdditionalProperties="RuntimeIdentifier=%(_TFMS.RID);TargetFramework=%(_TFMS.Identity)" />
    </ItemGroup>

    <!-- Ask MSBuild to build all of the requests we just made. The MSBuild Task recognizes the
    AdditionalProperties metadata and will apply that to each specific build, we can specify the things
    that are common to all of the builds here.  Unsetting RuntimeIdentifiers and TargetFrameworks
    ensures that the SDK targets detect that these are single-RID/single-TFM builds accurately, and
    since we're pretty certain there are no data dependencies here we can have the builds operate in
    parallel. -->
    <MSBuild
        Projects="@(_RIDSpecificFSACBuild)"
        Targets="Publish"
        Properties="Configuration=Release;SelfContained=true"
        RemoveProperties="RuntimeIdentifiers;TargetFrameworks"
        BuildInParallel="true" />
  </Target>

  <Import Project="..\..\.paket\Paket.Restore.targets" />
</Project>
